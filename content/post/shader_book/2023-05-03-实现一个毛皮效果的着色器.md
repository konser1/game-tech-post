---
title: "实现一个毛皮效果的着色器"
date: 2023-05-03T20:52:16+08:00
# weight: 1
# aliases: ["/first"]
tags: ["U3D", "Shader", "Cookbook", "中文版"]
categories: ["shader"]
author: "Link"
---

## 实现一个毛皮效果的着色器   
材质的外观取决于它的物理结构。着色器试图去模拟它们，但在那样做的过程中，它们都把光的行为方式过度的简化了。因为材质有肉眼可见的复杂结构所以渲染起来尤其的难。比如大多数的纺织布料和动物的毛皮。在这个知识点中将会展示去模拟皮毛和其他材质（比如草）的可能性，而不仅仅是限于那些平坦的的表面模拟。为了完成这些，同样的材质将会被一遍又一遍的进行多次绘制，每一次都会增加它的大小。因此创造了皮毛的假象。   
<br>   
这里着色器所呈现出的效果基于了 ***Jonathan Czeck*** 和 ***Aras Pranckevičius*** 的工作成果：   
![diagram](/game-tech-post/img/shader_book/diagram111.png)   

***
<br>   

- **始前准备**   
  为了让这个知识点能起效果，你需要准备两样东西。首先是一张皮毛的纹理因为它要呈现外观。其次是另外一张用来表示皮毛分布的纹理，并且它要跟前一张纹理高度匹配。下面的图片展示的是美洲豹的毛皮纹理（左）和它可能的控制遮罩纹理（右）：   
  ![diagram](/game-tech-post/img/shader_book/diagram112.png)   
  <br>   
  白像素的控制遮罩将从原始的材质挤压而来，模拟了一张毛皮。那些白像素分布稀疏程度非常的重要，因为它能给我们一种材料是由很多细小的毛发构成的假象。创建一张那样的纹理的简单方式如下：   
  - 1.给你的原始纹理设置一个阈值，好让原始纹理失去毛皮厚度的时候截取斑点纹理。
  - 2.添加一个噪音过滤器让图像像素画。噪音的RGB通道一定去掉关联从而获得黑白的结果。
  - 3.为了看起来真实一点，覆盖一个 **Perlin** 噪音过滤器来给毛皮添加一些变化。
  - 4.最后，再应用一个阈值过滤器让纹理的像素更好的分离。
  <br>   
  跟其他着色器开始前一样，你需要创建一个新的 **标准着色器（standard shader）** 和材质来容纳它们。   


***
<br>   

- **操作步骤**   
  对于这个知识点，我们能开始修改我们的 **标准着色器（standard shader）** 了：   
  - 1.在着色器的 **属性（Properties）** 上添加下面的代码：
  ```c#
  Properties 
  {
    _Color ("Main Color", Color) = (1,1,1,1)
    _MainTex ("Base (RGB) Trans (A)", 2D) = "white" {}
    _Glossiness ("Smoothness", Range(0,1)) = 0.5
    _Metallic ("Metallic", Range(0,1)) = 0.0
    
    _FurLength ("Fur Length", Range (.0002, 1)) = .25
    _Cutoff ("Alpha cutoff", Range(0,1)) = 0.5 // how "thick"
    _CutoffEnd ("Alpha cutoff end", Range(0,1)) = 0.5 // how thick they are at the end
    _EdgeFade ("Edge Fade", Range(0,1)) = 0.4
    
    _Gravity ("Gravity direction", Vector) = (0,0,1,0)
    _GravityStrength ("G strenght", Range(0,1)) = 0.25
  }
  ```
  - 2.这个着色器要求你重复同一个通道多次。你将会使用在 ***使用CG包含让着色器模块化*** 部分介绍的技术在外部文件中的单个通道来对所有的代码进行必要的分组整理。让我们使用下面的代码开始创建一个名为 **FurPass.cginc** 的新CG包含文件：   
  ```c#
  #pragma target 3.0
  
  fixed4 _Color;
  sampler2D _MainTex;
  half _Glossiness;
  half _Metallic;
  
  uniform float _FurLength;
  uniform float _Cutoff;
  uniform float _CutoffEnd;
  uniform float _EdgeFade;
  
  uniform fixed3 _Gravity;
  uniform fixed _GravityStrength;
  
  void vert (inout appdata_full v)
  {
  	fixed3 direction = lerp(v.normal, _Gravity * _GravityStrength + v.normal * (1-_GravityStrength), FUR_MULTIPLIER);
  	v.vertex.xyz += direction * _FurLength * FUR_MULTIPLIER * v.color.a;
  	//v.vertex.xyz += v.normal * _FurLength * FUR_MULTIPLIER * v.color.a;
  }
  
  struct Input 
  {
  	float2 uv_MainTex;
  	float3 viewDir;
  };
  
  void surf (Input IN, inout SurfaceOutputStandard o) 
  {
  	fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
  	o.Albedo = c.rgb;
  	o.Metallic = _Metallic;
  	o.Smoothness = _Glossiness;
  
  	//o.Alpha = step(_Cutoff, c.a);
  	o.Alpha = step(lerp(_Cutoff,_CutoffEnd,FUR_MULTIPLIER), c.a);
  
  	float alpha = 1 - (FUR_MULTIPLIER * FUR_MULTIPLIER);
  	alpha += dot(IN.viewDir, o.Normal) - _EdgeFade;
  
  	o.Alpha *= alpha;
  }
  ```
  - 3.返回你开始的哪个着色器然后再 **ENDCG** 后面添加这个额外的通道：   
  ```c#
  CGPROGRAM
  #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
  #define FUR_MULTIPLIER 0.05
  #include "FurPass.cginc"
  ENDCG
  ```
  - 4.要添加更多的通道，需要逐渐增加 **FUR_MULTIPLIER**。你可以得到20个通道，从 **0.05** 到 **0.95**。   
  
  <br>   

  当着色器编译完成并且挂载到一个材质上时，你就可以从 **检查器（Inspector）** 上修改它的外观了。**Fur Length** 属性决定了毛皮外壳的厚度，也就是毛发的长度。越长的毛发可能需要更多的通道来让它看起来更真实。**Alpha Cutoff** 和 **Alpha Cutoff End** 被用于控制毛发的浓密程度和毛发的逐渐变疏程度。**Edge Fade** 决定了毛皮的最终透明度，让毛皮看起来有种毛茸茸的效果。软质的材料应该要有 **high Edge Fade** 这个属性。最后，**Gravity Direction** 和 **Gravity Strength** 可以让这层毛皮模拟重力的效果。   
  [**原书作者这里的代码由有个严重问题，就是书上的代码跟实际能运行起来的代码有很大的差别，我在这后面贴上着色器的完整代码，译者注**]。   
  - 着色器的完整代码：   
  ```c#
  Shader "Custom/IAFS" 
  {
    Properties 
    {
        _Color ("Main Color", Color) = (1,1,1,1)
        _MainTex ("Base (RGB) Trans (A)", 2D) = "white" {}
        _Glossiness ("Smoothness", Range(0,1)) = 0.5
        _Metallic ("Metallic", Range(0,1)) = 0.0

        _FurLength ("Fur Length", Range (.0002, 1)) = .25
        _Cutoff ("Alpha cutoff", Range(0,1)) = 0.5 // how "thick"
        _CutoffEnd ("Alpha cutoff end", Range(0,1)) = 0.5 // how thick they are at the end
        _EdgeFade ("Edge Fade", Range(0,1)) = 0.4

        _Gravity ("Gravity direction", Vector) = (0,0,1,0)
        _GravityStrength ("G strenght", Range(0,1)) = 0.25
    }
    
    SubShader 
    {
        Tags {"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent"}
        ZWrite On
        LOD 200

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows
        #pragma target 3.0

        fixed4 _Color;
        sampler2D _MainTex;
        half _Glossiness;
        half _Metallic;
        
        struct Input 
        {
            float2 uv_MainTex;
        };

        void surf (Input IN, inout SurfaceOutputStandard o) 
        {
            fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
            o.Albedo = c.rgb;
            o.Metallic = _Metallic;
            o.Smoothness = _Glossiness;
            o.Alpha = c.a;
        }
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.05
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.1
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.15
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.20
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.25
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.30
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.35
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.40
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.45
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.50
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.55
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.60
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.65
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.70
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.75
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.80
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.85
        #include "FurPass.cginc"
        ENDCG
  
        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.90
        #include "FurPass.cginc"
        ENDCG

        CGPROGRAM
        #pragma surface surf Standard fullforwardshadows alpha:blend vertex:vert
        #define FUR_MULTIPLIER 0.95
        #include "FurPass.cginc"
        ENDCG
    }
    Fallback "Diffuse"
  }
  ```
  - **FurPass.cginc** 的完整代码：   
  ```c#
  #pragma target 3.0

  fixed4 _Color;
  sampler2D _MainTex;
  half _Glossiness;
  half _Metallic;
  
  uniform float _FurLength;
  uniform float _Cutoff;
  uniform float _CutoffEnd;
  uniform float _EdgeFade;
  
  uniform fixed3 _Gravity;
  uniform fixed _GravityStrength;
  
  void vert (inout appdata_full v)
  {
    fixed3 direction = lerp(v.normal, _Gravity * _GravityStrength + v.normal * (1-_GravityStrength), FUR_MULTIPLIER);
    v.vertex.xyz += direction * _FurLength * FUR_MULTIPLIER * v.color.a;
    //v.vertex.xyz += v.normal * _FurLength * FUR_MULTIPLIER * v.color.a;
  }
  
  struct Input 
  {
    float2 uv_MainTex;
    float3 viewDir;
  };
  
  void surf (Input IN, inout SurfaceOutputStandard o) 
  {
    fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
    o.Albedo = c.rgb;
    o.Metallic = _Metallic;
    o.Smoothness = _Glossiness;

    //o.Alpha = step(_Cutoff, c.a);
    o.Alpha = step(lerp(_Cutoff,_CutoffEnd,FUR_MULTIPLIER), c.a);

    float alpha = 1 - (FUR_MULTIPLIER * FUR_MULTIPLIER);
    alpha += dot(IN.viewDir, o.Normal) - _EdgeFade;

    o.Alpha *= alpha;
  }
  ```


***
<br>   

- **原理介绍**   
  
